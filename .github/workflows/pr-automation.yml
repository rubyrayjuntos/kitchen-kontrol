name: PR Automation & Labeling

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
  issues:
    types: [opened, edited, labeled]

jobs:
  pr-checks:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Check PR title format
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          
          # Check if title matches conventional commit format
          if [[ $TITLE =~ ^(feat|fix|docs|style|refactor|perf|test|chore)(\(.+\))?:\ .+ ]]; then
            echo "âœ“ PR title follows conventional commits format"
          else
            echo "âš  PR title should follow conventional commits format"
            echo "Format: <type>(<scope>): <description>"
            echo "Example: feat(auth): add login validation"
          fi
      
      - name: Check PR description
        run: |
          BODY="${{ github.event.pull_request.body }}"
          
          if [ -z "$BODY" ]; then
            echo "âš  Warning: PR description is empty"
          else
            echo "âœ“ PR has description"
            
            # Check for common sections
            if [[ $BODY == *"## Changes"* ]] || [[ $BODY == *"## Description"* ]]; then
              echo "âœ“ PR includes change description"
            fi
            
            if [[ $BODY == *"## Testing"* ]] || [[ $BODY == *"## Tests"* ]]; then
              echo "âœ“ PR includes testing information"
            fi
            
            if [[ $BODY == *"## Related"* ]] || [[ $BODY == *"Fixes #"* ]]; then
              echo "âœ“ PR links to related issues"
            fi
          fi
      
      - name: Check commit messages
        run: |
          COMMITS=$(git rev-list origin/main..${{ github.head_ref }} 2>/dev/null || echo "")
          
          if [ -z "$COMMITS" ]; then
            echo "âœ“ No commit check needed (force push or new branch)"
          else
            COUNT=$(echo "$COMMITS" | wc -l)
            echo "âœ“ PR has $COUNT commits"
          fi
      
      - name: Assign labels based on content
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const { pull_request } = context.payload;
            const labels = [];
            
            // Check PR title for labels
            const title = pull_request.title.toLowerCase();
            
            if (title.includes('test')) labels.push('testing');
            if (title.includes('fix')) labels.push('bug');
            if (title.includes('feat')) labels.push('feature');
            if (title.includes('doc')) labels.push('documentation');
            if (title.includes('perf')) labels.push('performance');
            if (title.includes('refactor')) labels.push('refactor');
            
            // Check PR body for testing information
            if (pull_request.body && pull_request.body.includes('test')) {
              if (!labels.includes('testing')) labels.push('testing');
            }
            
            // Add labels if any were detected
            if (labels.length > 0) {
              github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: labels
              });
              console.log('Added labels:', labels.join(', '));
            }
        continue-on-error: true

  issue-routing:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues'
    
    steps:
      - name: Route issue to appropriate team
        uses: actions/github-script@v7
        with:
          script: |
            const { issue } = context.payload;
            const labels = [];
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            
            // Route based on content
            if (title.includes('bug') || body.includes('error')) {
              labels.push('bug');
            }
            if (title.includes('feature') || title.includes('request')) {
              labels.push('feature-request');
            }
            if (title.includes('doc') || body.includes('documentation')) {
              labels.push('documentation');
            }
            if (title.includes('test')) {
              labels.push('testing');
            }
            if (title.includes('security')) {
              labels.push('security');
            }
            
            // Default to 'needs-triage' if no specific label
            if (labels.length === 0) {
              labels.push('needs-triage');
            }
            
            // Add labels to issue
            if (labels.length > 0) {
              github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: labels
              });
              console.log('Added labels:', labels.join(', '));
            }
        continue-on-error: true
      
      - name: Add welcome comment to new issues
        uses: actions/github-script@v7
        if: github.event.action == 'opened'
        with:
          script: |
            const { issue } = context.payload;
            
            github.rest.issues.createComment({
              issue_number: issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸ‘‹ Thank you for opening this issue! We appreciate your contribution.

Please ensure you have:
- [ ] Provided clear reproduction steps (for bugs)
- [ ] Included relevant error messages or screenshots
- [ ] Checked for existing similar issues
- [ ] Followed our code of conduct

Our team will review and respond as soon as possible. ðŸš€`
            });
        continue-on-error: true
